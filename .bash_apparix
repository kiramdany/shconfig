#  BASH-style functions
#
#  Name this file for example .bash_apparix in your $HOME directory
#  and put the line 'source $HOME/.bash_apparix' (without quotes)
#  in the file $HOME/.bashrc.


function to () {
  # This is a builtin command that returns 0 exit status. For use with the $? check below
  true
  if test "$1"; then
    # Take everything before the first /
    local bookmark=${1%%/*}
    # Take everything after the first /
    local initialPath=${1#*/}
    # Hacky check to see if bookmark doesn't have a trailing slash
    if [ "$bookmark" != "$initialPath" ]; then
      shift
      # Add the first space if the path contains spaces. More than one space is not supported
      local additionalPath="${*+ ${*}}"
      # First space needs to be included in $additionalPath, otherwise path will be incorrect when $additionalPath is empty
      local path=$initialPath$additionalPath
    fi
    
    local loc="$(apparix $bookmark)/$path"
  else
    loc=$HOME
  fi
  if [ $? -eq 0 ]; then
    cd "$loc"
  fi
}

function bm () {
  if test "$2"; then
    apparix --add-mark "$1" "$2";
  elif test "$1"; then
    apparix --add-mark "$1";
  else
    apparix --add-mark;
  fi
}

# function to generate list of completions from .apparixrc
function _apparix_aliases () {
  local debugDir="/Users/k.ramdany/Documents/Playground/BashDebug/"
  local command=$1
  local current=$2
  local previous=$3
  # Take everything before the first /
  local bookmark=${2%%/*}
  
  # Take everything after the first /
  local initialPath=${2#*/}

  # Take everything before the first /
  local bookmark="${COMP_WORDS[1]%%/*}"
  # Take everything after the first /
  local initialPath="${COMP_WORDS[1]#*/}"
  # Hacky check to see if bookmark doesn't have a trailing slash
  if [ "$bookmark" = "$initialPath" ]; then
    # grepping with -i as my bash settings have readline completions case insensitive as well
    local replies=( $( cat $HOME/.apparixrc | grep -i "j,$bookmark.*" | cut -f2 -d, ) )
    
    # Should do a check if there are any matches at all
    
    # If compreply has length 1 add a trailing slash
    if [ ${#replies[@]} -eq 1 ]; then
      COMPREPLY=( ${replies[0]}/ )
    else
      true
      COMPREPLY=( "${replies[@]}" )
    fi
  else
    local pathArray=( "${COMP_WORDS[@]}" )
    # echo pathArray
#     echo ${pathArray[@]}
#     echo
    unset pathArray[0]
    unset pathArray[1]
    # echo "${pathArray[@]}"
    # Add the first space if the path contains spaces. More than one space is not supported
    local additionalPath="${pathArray[@]+ ${pathArray[@]}}"
    # First space needs to be included in $additionalPath, otherwise path will be incorrect when $additionalPath is empty
    local path="$initialPath$additionalPath"
    local loc="$(apparix $bookmark)/$path"
    # Get everything before the last slash
    local currDir="${path%/*}"
    # nullglobsa=$(shopt -p nullglob)
    
    echo "$currDir" >> "${debugDir}currDir"
    echo "$path" >> "${debugDir}path"
    echo "$bookmark" >> "${debugDir}bookmark"

    
    local replies=()
    # BUG: replies aren't properly stripped because my setting has compgen being case insensitive
    local IFS=$'\n'; for i in $(compgen -f "$loc"); do
      # BUG: shouldn't completely strip out $loc, want to show complete file name in the comp reply
      replies+=( "${i##*/}" )
     done
     echo "${replies[@]}" >> "${debugDir}replies"
     echo "$COMP_CWORD" >> "${debugDir}COMP_CWORD"
     echo "${COMP_WORDS[@]}" >> "${debugDir}COMP_WORDS"
     # echo "${replies[@]}"
     # If compreply has length 1 make sure that current input is not completely replaced by the suggestion
     # IMPROVEMENT: This should check whether it is a folder or not and only add a slash if directory
     
     
     # Need to do a hacky check between currDir and path, to see if currDir is an actual directory
     
     
     if [ ${#replies[@]} -eq 1 ]; then
       # Checkwhether CWORD is the one that has the apparix bookmark or just a space in a directory name
       if [ $COMP_CWORD -gt 1 ]; then
         # Would need to do a check to see if current compword is a directory
         # Similar to path and currDir
         # Will have add difference between replies[0] and path(after the last slash)
         trailing="${path##*/}"
         # Using perl as BSD sed (MacOS) doesn't support case insensitive matching
         reply=$(echo ${replies[0]} | perl -pe "s/${trailing}//i")
         COMPREPLY=( "${COMP_WORDS[$COMP_CWORD]}${reply}"/ )
       else
         # true
         if [ ${currDir} = ${path} ]; then
           COMPREPLY=( "${bookmark}/${replies[0]}"/ )
         else
           COMPREPLY=( "${bookmark}/$currDir/${replies[0]}"/ )
         fi
       fi
     elif [ ${#replies[@]} -eq 0 ]; then
       true
     else
       # Will need a condition to check whether there is anything in common between the replies, if so return only the common bit with the extra prefixes included so that the current arguments aren't clobbered
       COMPREPLY=( "${replies[@]}" )
       # BUG: Some bug here when there is more than one completion but it has completed as far as what is in common between the replies
     fi
    # $nullglobsa
  fi
  # Can't remember what this is for
  $nullglobsa
  echo "${COMPREPLY[@]}" >> "${debugDir}COMPREPLY"
  return 0
}

# Feature: This shouldn't really be an alias, it should follow how to() works but without the cd
alias ap='apparix'


# command to register the above to expand when the 'to' command's args are
# being expanded
complete -o nospace -F _apparix_aliases to
complete -o nospace -F _apparix_aliases apparix
# BUG: in the current usage of ap, the completition is actually incorrect
complete -o nospace -F _apparix_aliases ap

export APPARIXLOG=$HOME/.apparixlog
